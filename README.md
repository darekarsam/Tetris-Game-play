# Tetris-Game-play
# Simple tetris program! v0.2

"""
1) This program simulates the tetris game. 
Formulation of the search problem.

Initial State: The initial state is the 20x10 blank board configuration.

Goal State: There is no goal state and the search may never stop. However, there is a stopping state which is when the pieces reach
the maximum height of the board and there is no space to accommodate the current falling piece as well as the next new piece.

State Space: The state space will contain all board configurations with the current piece placed as well as the next new piece placed.
In some special cases where one piece overpowers others(described below) we check the third piece look ahead as well.

Successor function: The successor function will generate all possible board configurations after placing the current piece
and the next new piece at all possible row column positions. If the pieces can be rotated, then the board configurations after placing all possible rotations is also generated by the successor function.
If the number of pieces on the board reach a count of 30, we calculate the piece which has
the maximum probability and assume this piece to fall after the next piece.
Evaluation function: The state n is evaluated by the f(n), where f(n)=h(n),where h(n) is the heuristic cost of the state.


Heuristics used in this problem:

Holes: A hole is an empty space surrounded by 'x' in the board.    
Wedges: A wedge is an empty space which is covered by a 'x' only from the above.    
Aggregate height: The sum of heights of all the columns of the board.    
Maximum height: The maximum height of all the column heights. We use maximum height because we want our board to be as free as possible to accommodate the #falling pieces.    
Complete lines: Complete lines are the best and occur when there are 10 'x' in a row.    
Bumpiness of the board: The sum of absolute differences of heights of adjacent columns.    
If the maxheight of the board becomes greater than 11, we give more importance to bumpiness.   
We also tried many other heuristics like pits which mean the pit in top most layer,
Blockades which mean the part which forms a hole or a wedge
after all possible combinations we decided to stay with the upper ones and ignore the ones which dont work


2) The search is a simple search till depth of 2 or 3(when number of pieces become greater than 30). We use a dictionary with key='set of moves', value=heuristic value of that state.
Initially we have a blank board, the current falling piece is placed at all possible row column 
and a heuristic value is calculated for it and stored in the dictionary. The piece is then rotated and again placed at all possible row column. 
This is done for all possible rotations of the piece.
These steps are then performed for the next piece and the third piece(in some cases) as well.
The set of moves with the maximum dictionary value is selected.

3) This code may give a bad score if one of the pieces overpowers other pieces i.e suppose we get more number of 'z'than others.
We are handling this by checking the piece with maximum probability and we assume that that piece will come after the next piece and then we make a third stage look ahead to get the best possible current state.   
The major problem we faced was getting the weights for different heuristics like holes, max_height, etc. This problem can be solved if we use techniques from reinforcement learning and machine learning to lear the weights automatically after several plays.
The choice of coefficients in the heuristic equation was made after repeatedly playing and checking which scenarios are the worst and giving weights accordingly.
We tried checking for the number of pits in the board but there was not much improvement, so we used bumpiness instead.


Also Implementated Adversarial Search such that our algorithm returns the worst possible next piece to the human player

